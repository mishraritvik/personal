When n is odd, n & (n - 1) simply evaluates to n - 1. When n is even, it
evaluates to n - 3. That is because when you subtract 1 from an odd number, it
only flips the last bit, so the rest will remain the same and the last bit will
got from 1 -> 0, thus resulting in a number that is 1 less than n. When you
subtract 1 from an even number, it flips all consecutive non-1 bits starting
from the rightmost. So, the number of times you can do n = n & (n - 1) before n
is less than or equal to 0 is the number of 1's in the starting n. Our previous
method for counting the number of ones required us to go through every bit in
the binary representation of the number. This way only requires us to do the
number of 1's iterations before it ends. Hence, it is always at least as fast
as the other algorithm, as the number of 1's is at most the number of bits in
the binary representation.
