Put your answers for the buddy-allocator problem in this file.  (The diagrams
will be > 80 characters wide; all other lines should be 80 characters or less.)

For part d, you can describe the heap state as follows:

Initial:

  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |                                                                               |
  |                                                                               |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

Step i:  alloc/free stuff

  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |                                                                               |
  |                                                                               |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

Indicate boundaries between blocks with "|" characters.  Since the
problem specifies a 16KB heap, each "+----+" section represents 1KB.

At the start of each allocated or free block in the heap, put the
following values:

 * On the first line, put "Ox _" where x is the order of the block, and
   "_" indicates a free block, or A/B/C/D/E indicates the name of the
   allocated block.

 * On the second line, put the size of the block:  for a free block, you
   can put "xxKB", where this is the size of the free block.  For a used
   block, put "xxxx", indicating the number of bytes in the used block.

For example, after a 6000 byte allocation, you might have this:

Step 1:  A = alloc(6000);

  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O8 A                                   |O8 _                                   |
  |6000                                   |8KB                                    |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

==== PUT YOUR ANSWERS BELOW THIS LINE ====

Part A.
MIN_BLOCK_SIZE is 32, and we have 2 ^ 31 bytes. So, the maximum size order is
log base 2(2 ^ 31 / 32) = 26. However, we will need to make space for the free
lists so the maximum size order will be one less, at 25. The first 26 * 4 bytes
= 104 bytes will be used to store the starting point of all of the explicit free
lists.


Part B.
int get_order_of_size(int size) {
    int factor = size / MIN_BLOCK_SIZE, order = 0, curr_factor = 1;
    while (curr_factor < factor) {
        curr_factor << 1;
        order++;
    }
    return order;
}


Part C.
The allocator will start by going through the explicit free list for the least
order blocks that the requested memory can fit in. If the free list is empty,
the (order)th value int in the memory pool will be negative (by design, we will
designate a negative value to mean that there are no more empty blocks). Then
the allocator will move on the (order + 1)th free list, and so on until it finds
a block. If it gets to the (max order)th free list and still there are no free
blocks, then it returns NULL.


Part D.
Initial:
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |09 _                                                                           |
  |16KB                                                                           |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

A = allocate(1400);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 A     |06 _     |07 _               |O8 _                                   |
  |1400     |2KB      |4KB                |8KB                                    |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

B = allocate(5500);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 A     |06 _     |07 _               |O8 B                                   |
  |1400     |2KB      |4KB                |5500                                   |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

C = allocate(800);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 A     |05 C|05 _|07 _               |O8 B                                   |
  |1400     |800 |1KB |4KB                |5500                                   |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

D = allocate(3200);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 A     |05 C|05 _|07 D               |O8 B                                   |
  |1400     |800 |1KB |3200               |5500                                   |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

free(A);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 _     |05 C|05 _|07 D               |O8 B                                   |
  |2KB      |800 |1KB |3200               |5500                                   |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

E = allocate(700);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 _     |05 C|05 E|07 D               |O8 B                                   |
  |2KB      |800 |700 |3200               |5500                                   |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

free(B);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 _     |05 C|05 E|07 D               |O8 _                                   |
  |2KB      |800 |700 |3200               |8KB                                    |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

free(C);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O6 _     |05 _|05 E|07 D               |O8 _                                   |
  |2KB      |1KB |700 |3200               |8KB                                    |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

free(E);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |O7 _               |07 D               |O8 _                                   |
  |4KB                |3200               |8KB                                    |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

free(D);
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
  |09 _                                                                           |
  |16KB                                                                           |
  +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+


Part E.
The problem with buddy allocators is the potential for wasting a lot of memory.
In the example given, if 8193 bytes was requested (8KB + 1 byte) then it would
require the entire memory, as the only options are powers of two apart and 8KB
is not large enough. So, it is possible for the memory utilization to be maxed
out at just over 50% if the case where the memory needed is just slightly above
one of the possible sizes and so the next size which is twice as large is used.


Part F.
The buddy allocator is closest to the best-fit placement strategy. This is
because it starts out with looking for blocks that are of the minimum order
needed to fit the requested memory size, and then only looks at the next order
once it does not find any of the smallest possible size.


Part G.
The allocator can defer the coalescing of two buddies until it knows that a
block of that size is actually needed, as opposed to doing it regardless. The
case deferred coalescing prevents is:
Step 1. free order n block is broken up into two n - 1 blocks to alloc an n - 1
Step 2. order n - 1 block is freed
Step 3. the two n - 1 buddies are coalesced
Step 4. free order n block is broken up into two n - 1 blocks to alloc an n - 1
If coalescing is deferred, Step 3 will not occur as the buddies will be left
separate. Then, if step 4 were an allocation of order n, the two buddies would
coalesce in order to make a large enough block.
